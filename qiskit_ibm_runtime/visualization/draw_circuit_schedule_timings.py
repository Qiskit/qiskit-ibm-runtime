"""This module defines the functionality to visualize the schedule of a Qiskit circuit compiled code"""

import argparse
import pandas as pd
import plotly.graph_objs as go

plotly_colors = [
    "rgb(141,211,199)",
    "rgb(251,128,114)",
    "rgb(128,177,211)",
    "rgb(179,222,105)",
    "rgb(255,237,111)",
    "rgb(253,180,98)",
    "rgb(252,205,229)",
    "rgb(217,217,217)",
    "rgb(188,128,189)",
    "rgb(204,235,197)",
    "rgb(255,255,179)",
    "rgb(190,186,218)",
    "rgb(253,205,172)",
    "rgb(203,213,232)",
    "rgb(244,202,228)",
    "rgb(230,245,201)",
    "rgb(255,242,174)",
    "rgb(241,226,204)",
    "rgb(204,204,204)",
]


class Schedule:
    """The Schedule class encapsulates the data of a Qiskit circuit schedule and contains the functionality
    to visualize it"""

    def __init__(self, file_name: str):
        """Initialize a Schedule object using the schedule file generated by the compiler"""
        with open(file_name, encoding="utf-8") as file:
            data = file.readlines()
            sched_dict = []
        for line in data:
            if line == "":
                continue
            words = line.split(",")
            if "shift_phase" in words[0]:
                continue
            if len(words) != 6:
                raise ValueError(
                    "Cannot interpret timeline data that doesn't have the format \\\
                        <RowType,Operation,Qubit,T0,Duration>"
                )
            sched_dict.append(
                {
                    "RowType": words[0],
                    "CallSeq": words[1],
                    "Task": words[2],
                    "Start": int(words[3]),
                    "Finish": int(words[3]) + int(words[4]),
                    "Operation": words[5],
                    "CallSeqName": words[1].split("_")[0],
                }
            )
        self.df = pd.DataFrame(sched_dict)
        self.df.sort_values("Task", inplace=True)
        self.qubit_rows = self.df["Task"].unique()
        self.qubit_rows.sort()
        self.qubit_rows = list(self.qubit_rows)
        self.qubit_rows.reverse()
        self.qubit_rows = [""] + self.qubit_rows
        self.max_time = max(self.df["Finish"])
        self.color_map = dict(zip(self.df["CallSeqName"].unique(), plotly_colors))
        self.annotations = []
        self.legend = []
        self.fig = None

    def get_y0_y1_rect(self, row_type: str):
        """Get offsets for generated rectangles"""
        if row_type == "main":
            return (-0.4, 0.4, 0)
        if row_type == "then":
            return (0, 0.4, 0.25)
        if row_type == "else":
            return (-0.4, 0, -0.25)
        raise ValueError("Unexpected row type provided")

    def draw_rectangle(self, row: pd.core.series.Series):
        """Generate rectangles"""
        y0, y1, annotation_y = self.get_y0_y1_rect(row[1]["RowType"])

        # extend barriers vertically beyond operations
        if row[1]["CallSeqName"] == "barrier":
            y0 -= 0.05
            y1 += 0.05

        self.fig.add_trace(
            go.Scatter(
                x=[
                    row[1]["Start"],
                    (row[1]["Start"] + row[1]["Finish"]) / 2,
                    row[1]["Finish"],
                    row[1]["Finish"],
                    (row[1]["Start"] + row[1]["Finish"]) / 2,
                    row[1]["Start"],
                    row[1]["Start"],
                    None,
                ],
                y=[
                    self.qubit_rows.index(row[1]["Task"]) + y0,
                    self.qubit_rows.index(row[1]["Task"]) + y0,
                    self.qubit_rows.index(row[1]["Task"]) + y0,
                    self.qubit_rows.index(row[1]["Task"]) + y1,
                    self.qubit_rows.index(row[1]["Task"]) + y1,
                    self.qubit_rows.index(row[1]["Task"]) + y1,
                    self.qubit_rows.index(row[1]["Task"]) + y0,
                    None,
                ],
                mode="markers",
                hoverinfo="x+text",
                name=row[1]["CallSeqName"],
                text="<br>".join(
                    [
                        "CallSeq: " + row[1].CallSeq,
                        "Operation: " + row[1].Operation,
                        "Start: " + str(row[1].Start),
                        "Finish: " + str(row[1].Finish),
                        "Duration: " + str(row[1].Finish - row[1].Start),
                    ]
                ),
                legendgroup=row[1]["CallSeqName"],
                line={"color": "black"},
                fill="toself",
                fillcolor=self.color_map[row[1]["CallSeqName"]],
                showlegend=row[1]["CallSeqName"] not in self.legend,
            )
        )
        self.legend += [row[1]["CallSeqName"]]

        # hide text if drawing a barrier
        text = row[1]["CallSeqName"]
        if text == "barrier":
            text = ""
        else:
            text = row[1]["CallSeqName"] + "_" + row[1]["Operation"]

        self.annotations.append(
            {
                "x": ((row[1]["Start"] + row[1]["Finish"]) / 2),
                "y": self.qubit_rows.index(row[1]["Task"]) + annotation_y,
                "showarrow": False,
                "font": {"color": "black", "size": 10},
                "text": text,
                "textangle": 0,
            }
        )

    def get_diamond_factor(self, row_type: str):
        """Get offsets for generated diamonds"""
        if row_type == "main":
            return 0
        if row_type == "then":
            return 0.2
        if row_type == "else":
            return -0.2
        raise ValueError("Unexpected row type provided")

    def draw_diamond(self, row: pd.core.series.Series):
        """Generate diamonds"""
        factor = self.get_diamond_factor(row[1]["RowType"])
        self.fig.add_trace(
            go.Scatter(
                x=[
                    row[1]["Start"],
                    row[1]["Start"] + 1,
                    row[1]["Start"],
                    row[1]["Start"] - 1,
                    row[1]["Start"],
                    None,
                ],
                y=[
                    self.qubit_rows.index(row[1]["Task"]) + factor - 0.2,
                    self.qubit_rows.index(row[1]["Task"]) + factor,
                    self.qubit_rows.index(row[1]["Task"]) + factor + 0.2,
                    self.qubit_rows.index(row[1]["Task"]) + factor,
                    self.qubit_rows.index(row[1]["Task"]) + factor - 0.2,
                    None,
                ],
                mode="markers",
                hoverinfo="x+text",
                name=row[1]["CallSeqName"],
                text="<br>".join(
                    [
                        "CallSeq: " + row[1].CallSeq,
                        "Operation: " + row[1].Operation,
                        "Start: " + str(row[1].Start),
                        "Finish: " + str(row[1].Finish),
                        "Duration: " + str(row[1].Finish - row[1].Start),
                    ]
                ),
                legendgroup=row[1]["CallSeqName"],
                line={"color": "black"},
                fill="toself",
                fillcolor=self.color_map[row[1]["CallSeqName"]],
                showlegend=row[1]["CallSeqName"] not in self.legend,
            )
        )
        self.legend += [row[1]["CallSeqName"]]
        self.annotations.append(
            {
                "x": ((row[1]["Start"] + row[1]["Finish"]) / 2),
                "y": self.qubit_rows.index(row[1]["Task"]) + factor,
                "showarrow": True,
                "font": {"color": "black", "size": 10},
                "text": row[1]["CallSeqName"] + "_" + row[1]["Operation"],
                "textangle": 0,
            }
        )

    def create_figure(self, filter_awgr=False, filter_barrier=False):
        """Generate a figure representing the circuit schedule"""

        # Create a barebones graph with the x axis and y axis populated
        self.fig = go.Figure()
        self.fig.update_layout(
            title_text="Circuit Schedule",
            paper_bgcolor="rgba(255,255,255,1)",
            plot_bgcolor="rgba(255,255,255,1)",
            title_font_size=20,
            title_x=0.5,
        )
        self.fig.update_xaxes(
            range=(0, self.max_time + 1),
            showline=True,
            linewidth=1,
            linecolor="black",
            mirror=True,
        )
        self.fig.update_yaxes(
            showline=True,
            linewidth=1,
            linecolor="black",
            mirror=True,
            gridcolor="rgba(38,38,38,0.15)",
        )
        self.fig.update_layout(
            xaxis_type="linear",
            xaxis_title="Cycles",
            yaxis_title="Qubit/Channel",
            height=200 + 60 * len(self.qubit_rows),
        )
        self.fig.update_layout(
            xaxis={
                "rangeselector": {"buttons": list([])},
                "rangeslider": {"visible": True},
            }
        )
        # Process each row with operation of duration non-zero
        for row in self.df.iterrows():
            if row[1]["Task"].startswith("AWGR") and filter_awgr:
                continue
            if row[1]["CallSeqName"] == "barrier" and filter_barrier:
                continue
            if "shift_phase" not in row[1]["Operation"]:
                self.draw_rectangle(row)

        # Process each row with an operation of duration 0
        for row in self.df.iterrows():
            if row[1]["Task"].startswith("AWGR") and filter_awgr:
                continue
            if row[1]["CallSeqName"] == "barrier" and filter_barrier:
                continue
            if "shift_phase" in row[1]["Operation"]:
                self.draw_diamond(row)

        # Add annotations
        self.fig["layout"]["annotations"] = self.annotations

        # Update the xtick values
        self.fig.update_layout(
            yaxis={
                "tickmode": "array",
                "tickvals": list(range(0, len(self.qubit_rows))),
                "ticktext": self.qubit_rows,
            }
        )

        self.fig.update_traces(
            hoverinfo="x+text",
            marker={"size": 0.01},
            mode="lines+markers",
        )

        # Add a button that helps with annotations
        self.fig.update_layout(
            updatemenus=[
                {
                    "type": "dropdown",
                    "direction": "down",
                    "buttons": list(
                        [
                            {
                                "args": [{"annotations": self.fig.layout.annotations}],
                                "label": "Show Annotations",
                                "method": "relayout",
                            },
                            {
                                "args": [{"annotations": []}],
                                "label": "Hide Annotations",
                                "method": "relayout",
                            },
                        ]
                    ),
                    "pad": {"r": 10, "t": 10},
                    "showactive": True,
                    "x": 0,
                    "xanchor": "left",
                    "y": 1.1,
                    "yanchor": "top",
                }
            ]
        )

        return self.fig


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="Schedule Visualizer",
        description="Visualizes the schedule of a Qiskit circuit after compilation.",
    )
    parser.add_argument(
        "filename", help="Schedule file produced by the compiler when generating a payload"
    )
    parser.add_argument("--filter-awgr", help="Filter AWGR channels", action="store_true")
    parser.add_argument("--include-barriers", help="Filter Barriers", action="store_false")
    args = parser.parse_args()
    schedule = Schedule(args.filename)
    schedule.create_figure(args.filter_awgr, args.include_barriers).show()
