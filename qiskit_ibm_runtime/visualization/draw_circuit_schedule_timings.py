# This code is part of Qiskit.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.


"""This module defines the functionality to visualize the schedule of a Qiskit circuit compiled code"""

from typing import Dict, Tuple, List, TYPE_CHECKING
from itertools import cycle

import plotly.graph_objects as go
from plotly.graph_objects import Figure as PlotlyFigure


import pandas as pd  # TODO: remove use of pandas


colors = [
    "rgb(141,211,199)",
    "rgb(251,128,114)",
    "rgb(128,177,211)",
    "rgb(179,222,105)",
    "rgb(255,237,111)",
    "rgb(253,180,98)",
    "rgb(252,205,229)",
    "rgb(217,217,217)",
    "rgb(188,128,189)",
    "rgb(204,235,197)",
    "rgb(255,255,179)",
    "rgb(190,186,218)",
    "rgb(253,205,172)",
    "rgb(203,213,232)",
    "rgb(244,202,228)",
    "rgb(230,245,201)",
    "rgb(255,242,174)",
    "rgb(241,226,204)",
    "rgb(204,204,204)",
]


READOUT_CHANNEL_PREFIX = "AWGR"


class CircuitSchedule:
    """
    TODO: Add docs.
    The Schedule class encapsulates the data of a Qiskit circuit schedule and contains the functionality
    to visualize it
    """

    def __init__(
        self,
        file_name: str,
    ):
        """
        TODO: Add docs.
        Initialize a Schedule object using the schedule file generated by the compiler
        """
        self.channels = None
        self.df = None

        raw_data = self._load(file_name)
        self.circuit_scheduling = self._parse(raw_data)
        # self.preprocess(circuit_scheduling)

        self.instruction_set = set()
        self.max_time = None
        self.color_map = {}
        self.annotations = []
        self.legend = set()

    def _load(self, file_name: str) -> List[str]:
        """
        TODO: Add checks and docs
        """
        with open(file_name, encoding="utf-8") as file:
            data = file.readlines()

        return data

    def _parse(self, raw_data: List[str]) -> List[Dict[str, str | int]]:
        """
        TODO: Add checks and docs
        """
        circuit_scheduling = []
        for line in raw_data:
            if line == "":
                continue
            words = line.split(",")
            if "shift_phase" in words[0]:
                continue
            if len(words) != 6:
                raise ValueError(
                    "Cannot interpret timeline data that doesn't have the format \\\
                        <RowType,Pulse,Qubit,T0,Duration>"
                )
            circuit_scheduling.append(
                dict(
                    Branch=words[0],
                    Instruction=words[1],
                    Channel=words[2],
                    Start=int(words[3]),
                    Finish=int(words[3]) + int(words[4]),
                    Pulse=words[5],
                    GateName=words[1].split("_")[0],
                )
            )
        return circuit_scheduling

    def preprocess(
        self,
        filter_awgr: bool = False,
        filter_barriers: bool = False,
        included_channels: list = None,
    ):
        """
        TODO: Add checks and docs
        """
        self.df = pd.DataFrame(self.circuit_scheduling)

        # filter channels
        if included_channels is not None and isinstance(included_channels, list):
            self.df = self.df[self.df["Channel"].isin(included_channels)]

        # filter AWGR channels
        if filter_awgr:
            self.df = self.df[~self.df["Channel"].str.startswith(READOUT_CHANNEL_PREFIX)]

        # filter barriers
        if filter_barriers:
            self.df = self.df[self.df["Instruction"] != "barrier"]

        self.df.sort_values("Channel", inplace=True)
        self.channels = self.df["Channel"].unique()  # TODO: maybe `instruments` is better?
        self.channels.sort()
        self.channels = list(self.channels)

        self.max_time = max(self.df["Finish"])

        self.instruction_set = self.df["GateName"].unique()

    @staticmethod
    def unpack_row(row: pd.core.series.Series) -> Tuple[str, str, str, int, int, str, str]:
        """
        TODO: Add docs
        """
        return (
            row[1].Branch,
            row[1].Instruction,
            row[1].Channel,
            row[1].Start,
            row[1].Finish,
            row[1].Pulse,
            row[1].GateName,
        )

    def get_trace_finite_duration_y_shift(self, branch: str) -> Tuple[float, float, float]:
        """
        TODO: Add docs
        Get offsets for generated rectangles
        """
        if branch == "main":
            return (-0.4, 0.4, 0)
        elif branch == "then":
            return (0, 0.4, 0.25)
        elif branch == "else":
            return (-0.4, 0, -0.25)
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def get_trace_zero_duration_y_shift(self, branch: str) -> float:
        """
        TODO: Add docs
        Get offsets for generated diamonds
        """
        if branch == "main":
            return 0
        elif branch == "then":
            return 0.2
        elif branch == "else":
            return -0.2
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def trace_finite_duration_instruction(self, row: pd.core.series.Series):
        """
        TODO: Add docs
        Generate rectangles
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = self.unpack_row(row)

        # compute trace y-position
        y0, y1, annotation_y = self.get_trace_finite_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_low = channel_y_loc + y0
        y_high = channel_y_loc + y1

        # extend barriers vertically beyond operations
        if gate_name == "barrier":
            y0 -= 0.05
            y1 += 0.05

        # Get gate trace
        # the gate is drawn as a 6-point closed rectangular to
        # allow convenient annotation display when hover
        trace = go.Scatter(
            x=[
                t_i,
                (t_i + t_f) / 2,
                t_f,
                t_f,
                (t_i + t_f) / 2,
                t_i,
                t_i,
                None,
            ],  # TODO: Figure out the None in the end
            y=[
                y_low,
                y_low,
                y_low,
                y_high,
                y_high,
                y_high,
                y_low,
                None,
            ],  # TODO: Figure out the None in the end
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    "Instruction: " + instruction,
                    "Pulse: " + pulse,
                    "Start: " + str(t_i),
                    "Finish: " + str(t_f),
                    "Duration: " + str(t_f - t_i),
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )

        # Get trace annotation
        # hide text if drawing a barrier
        text = "" if gate_name == "barrier" else f"{gate_name}_{pulse}"
        annotation = dict(
            x=((t_i + t_f) / 2),
            y=channel_y_loc + annotation_y,
            showarrow=False,
            font={"color": "black", "size": 10},
            text=text,
            textangle=0,
        )
        return (trace, annotation)

    def trace_zero_duration_instruction(self, row: pd.core.series.Series):
        """
        TODO: Add docs
        Generate diamonds
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = self.unpack_row(row)

        y_shift = self.get_trace_zero_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_mid = channel_y_loc + y_shift
        y_low = y_mid - 0.2
        y_high = y_mid + 0.2

        # Get trace
        # drawing zero duration traces as diamonds
        trace = go.Scatter(
            x=[t_i, t_i + 1, t_i, t_i - 1, t_i, None],
            y=[y_low, y_mid, y_high, y_mid, y_low, None],
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    f"Instruction: {instruction}",
                    f"Pulse: {pulse}",
                    f"Start: {t_i}",
                    f"Finish: {t_f}",
                    f"Duration: {t_f - t_i}",
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )

        # Get trace annotation
        annotation = dict(
            x=((t_i + t_f) / 2),
            y=y_mid,
            showarrow=True,
            font={"color": "black", "size": 10},
            text=f"{gate_name}_{pulse}",
            textangle=0,
        )
        return (trace, annotation)

    def populate_figure(self, fig: PlotlyFigure) -> PlotlyFigure:
        """
        TODO: Add docs
        """
        self.color_map = dict(zip(self.instruction_set, cycle(colors)))

        # Process instructions
        shift_phase_instructions = []
        for row in self.df.iterrows():
            (_, _, _, _, _, pulse, gate_name) = self.unpack_row(row)
            if "shift_phase" not in pulse:
                # Process instructions of finite duration
                trace, annotation = self.trace_finite_duration_instruction(row)
                self.legend.add(gate_name)
                self.annotations.append(annotation)
                fig.add_trace(trace)
            else:
                # cache for later tracing so it won't be covered
                shift_phase_instructions.append(row)

        # Process instructions of zero duration
        for row in shift_phase_instructions:
            trace, annotation = self.trace_zero_duration_instruction(row)
            self.legend.add(gate_name)
            self.annotations.append(annotation)
            fig.add_trace(trace)

        return fig


def draw_circuit_schedule_timing(
    schedule_file_path: str,  # TODO: this should be optional since the data may come directly from a result object
    included_channels: list = None,
    filter_readout_channels: bool = False,
    filter_barriers: bool = False,
    width: int = 1400,
) -> PlotlyFigure:
    r"""
    Draw a circuit schedule timing for :class:`~.CircuitSchedule`.

    Args:
        schedule_file_path: The path to the schedule file.
        included_channels: A list of channels to include in the plot.
        filter_readout_channels: If ``True``, remove all readout channels.
        filter_barriers: If ``True``, remove all barriers.
        width: The width of the returned figure.

    Returns:
        A plotly figure.
    """
    fig = go.Figure(layout=go.Layout(width=width))

    # Get the scheduling data
    schedule = CircuitSchedule(
        file_name=schedule_file_path,
    )

    # Process and filter
    schedule.preprocess(
        included_channels=included_channels,
        filter_awgr=filter_readout_channels,
        filter_barriers=filter_barriers,
    )

    # Setup the figure
    fig.update_layout(
        title_text="Payload Schedule",
        paper_bgcolor="rgba(255,255,255,1)",
        plot_bgcolor="rgba(255,255,255,1)",
        title_font_size=20,
        title_x=0.5,
    )
    fig.update_xaxes(
        range=(0, schedule.max_time + 1),  # TODO: Add X% padding if requested
        showline=True,
        linewidth=1,
        linecolor="black",
        mirror=True,
    )
    fig.update_yaxes(
        showline=True,
        linewidth=1,
        linecolor="black",
        mirror=True,
        gridcolor="rgba(38,38,38,0.15)",
    )
    fig.update_layout(
        xaxis_type="linear",
        xaxis_title="Cycles",  # TODO: convert to time if requested
        yaxis_title="Channel",
        height=200 + 60 * len(schedule.channels),
    )
    fig.update_layout(
        xaxis={
            "rangeselector": {"buttons": list([])},
            "rangeslider": {"visible": True},
        }
    )

    # Populate the figure with traces
    fig = schedule.populate_figure(fig=fig)

    # Add annotations
    fig["layout"]["annotations"] = schedule.annotations

    # Add a button to control annotations display
    fig.update_layout(
        updatemenus=[
            dict(
                type="dropdown",
                direction="down",
                buttons=list(
                    [
                        dict(
                            args=[{"annotations": fig.layout.annotations}],
                            label="Show Annotations",
                            method="relayout",
                        ),
                        dict(
                            args=[{"annotations": []}],
                            label="Hide Annotations",
                            method="relayout",
                        ),
                    ]
                ),
                pad={"r": 10, "t": 10},
                showactive=True,
                x=0,
                xanchor="left",
                y=1.1,
                yanchor="top",
            )
        ]
    )

    # Update the xtick values
    fig.update_layout(
        yaxis={
            "tickmode": "array",
            "tickvals": list(range(0, len(schedule.channels))),
            "ticktext": schedule.channels,
        }
    )

    # update annotation hovering
    fig.update_traces(
        hoverinfo="x+text",
        marker={"size": 0.01},
        mode="lines+markers",
    )

    return fig
