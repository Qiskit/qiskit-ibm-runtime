"""This module defines the functionality to visualize the schedule of a Qiskit circuit compiled code"""

import pandas as pd
import plotly.graph_objs as go

plotly_colors = [
    "rgb(141,211,199)",
    "rgb(251,128,114)",
    "rgb(128,177,211)",
    "rgb(179,222,105)",
    "rgb(255,237,111)",
    "rgb(253,180,98)",
    "rgb(252,205,229)",
    "rgb(217,217,217)",
    "rgb(188,128,189)",
    "rgb(204,235,197)",
    "rgb(255,255,179)",
    "rgb(190,186,218)",
    "rgb(253,205,172)",
    "rgb(203,213,232)",
    "rgb(244,202,228)",
    "rgb(230,245,201)",
    "rgb(255,242,174)",
    "rgb(241,226,204)",
    "rgb(204,204,204)",
]


READOUT_CHANNEL_PREFIX = "AWGR"


class Schedule:
    """
    TODO: Add docs.
    The Schedule class encapsulates the data of a Qiskit circuit schedule and contains the functionality
    to visualize it
    """

    def __init__(
        self,
        file_name: str,
        filter_awgr: bool = False,
        filter_barriers: bool = False,
        included_channels: list = None,
    ):
        """
        TODO: Add docs.
        Initialize a Schedule object using the schedule file generated by the compiler
        """
        self.filter_awgr = filter_awgr
        self.filter_barriers = filter_barriers
        self.included_channels = included_channels
        self.channels = None
        self.df = None

        raw_data = self._load(file_name)
        circuit_scheduling = self._parse(raw_data)
        self._preprocess(circuit_scheduling)

        self.max_time = max(self.df["Finish"])
        self.color_map = dict(zip(self.df["GateName"].unique(), plotly_colors))
        self.annotations = []
        self.legend = set()
        self.fig = None

    def _load(self, file_name: str) -> List[str]:
        """
        TODO: Add checks and docs
        """
        with open(file_name, encoding="utf-8") as file:
            data = file.readlines()

        return data

    def _parse(self, raw_data: List[str]) -> List[Dict[str, str | int]]:
        """
        TODO: Add checks and docs
        """
        circuit_scheduling = []
        for line in raw_data:
            if line == "":
                continue
            words = line.split(",")
            if "shift_phase" in words[0]:
                continue
            if len(words) != 6:
                raise ValueError(
                    "Cannot interpret timeline data that doesn't have the format \\\
                        <RowType,Pulse,Qubit,T0,Duration>"
                )
            circuit_scheduling.append(
                dict(
                    Branch=words[0],
                    Instruction=words[1],
                    Channel=words[2],
                    Start=int(words[3]),
                    Finish=int(words[3]) + int(words[4]),
                    Pulse=words[5],
                    GateName=words[1].split("_")[0],
                )
            )
        return circuit_scheduling

    def _preprocess(self, circuit_scheduling: List[Dict[str, str | int]]):
        self.df = pd.DataFrame(circuit_scheduling)

        # filter channels
        if self.included_channels is not None and isinstance(self.included_channels, list):
            self.df = self.df[self.df["Channel"].isin(self.included_channels)]

        # filter AWGR channels
        if self.filter_awgr:
            self.df = self.df[~self.df["Channel"].str.startswith(READOUT_CHANNEL_PREFIX)]

        # filter barriers
        print(self.filter_barriers)
        if self.filter_barriers:
            self.df = self.df[self.df["Instruction"] != "barrier"]

        self.df.sort_values("Channel", inplace=True)
        self.channels = self.df["Channel"].unique()  # TODO: maybe `instruments` is better?
        self.channels.sort()
        self.channels = list(self.channels)

    @staticmethod
    def unpack_row(row: pd.core.series.Series) -> Tuple[str, str, str, int, int, str, str]:
        """
        TODO: Add docs
        """
        return (
            row[1].Branch,
            row[1].Instruction,
            row[1].Channel,
            row[1].Start,
            row[1].Finish,
            row[1].Pulse,
            row[1].GateName,
        )

    def get_trace_finite_duration_y_shift(self, branch: str) -> Tuple[float, float, float]:
        """
        TODO: Add docs
        Get offsets for generated rectangles
        """
        if branch == "main":
            return (-0.4, 0.4, 0)
        elif branch == "then":
            return (0, 0.4, 0.25)
        elif branch == "else":
            return (-0.4, 0, -0.25)
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def get_trace_zero_duration_y_shift(self, branch: str) -> float:
        """
        TODO: Add docs
        Get offsets for generated diamonds
        """
        if branch == "main":
            return 0
        elif branch == "then":
            return 0.2
        elif branch == "else":
            return -0.2
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def trace_finite_duration_instruction(self, row: pd.core.series.Series):
        """
        TODO: Add docs
        Generate rectangles
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = self.unpack_row(row)

        # compute trace y-position
        y0, y1, annotation_y = self.get_trace_finite_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_low = channel_y_loc + y0
        y_high = channel_y_loc + y1

        # extend barriers vertically beyond operations
        if gate_name == "barrier":
            y0 -= 0.05
            y1 += 0.05

        # Get gate trace
        # the gate is drawn as a 6-point closed rectangular to
        # allow convenient annotation display when hover
        trace = go.Scatter(
            x=[
                t_i,
                (t_i + t_f) / 2,
                t_f,
                t_f,
                (t_i + t_f) / 2,
                t_i,
                t_i,
                None,
            ],  # TODO: Figure out the None in the end
            y=[
                y_low,
                y_low,
                y_low,
                y_high,
                y_high,
                y_high,
                y_low,
                None,
            ],  # TODO: Figure out the None in the end
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    "Instruction: " + instruction,
                    "Pulse: " + pulse,
                    "Start: " + str(t_i),
                    "Finish: " + str(t_f),
                    "Duration: " + str(t_f - t_i),
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )
        self.fig.add_trace(trace)
        self.legend.add(gate_name)

        # Get trace annotation
        # hide text if drawing a barrier
        text = "" if gate_name == "barrier" else f"{gate_name}_{pulse}"
        self.annotations.append(
            dict(
                x=((t_i + t_f) / 2),
                y=channel_y_loc + annotation_y,
                showarrow=False,
                font={"color": "black", "size": 10},
                text=text,
                textangle=0,
            )
        )

    def trace_zero_duration_instruction(self, row: pd.core.series.Series):
        """
        TODO: Add docs
        Generate diamonds
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = self.unpack_row(row)

        y_shift = self.get_trace_zero_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_mid = channel_y_loc + y_shift
        y_low = y_mid - 0.2
        y_high = y_mid + 0.2

        # Get trace
        # drawing zero duration traces as diamonds
        trace = go.Scatter(
            x=[t_i, t_i + 1, t_i, t_i - 1, t_i, None],
            y=[y_low, y_mid, y_high, y_mid, y_low, None],
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    "Instruction: " + instruction,
                    "Pulse: " + pulse,
                    "Start: " + str(t_i),
                    "Finish: " + str(t_f),
                    "Duration: " + str(t_f - t_i),
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )
        self.fig.add_trace(trace)
        self.legend.add(gate_name)

        # Get trace annotation
        self.annotations.append(
            dict(
                x=((t_i + t_f) / 2),
                y=y_mid,
                showarrow=True,
                font={"color": "black", "size": 10},
                text=f"{gate_name}_{pulse}",
                textangle=0,
            )
        )

    def setup_figure(self):
        """
        TODO: Add docs
        """
        self.fig.update_layout(
            title_text="Payload Schedule",
            paper_bgcolor="rgba(255,255,255,1)",
            plot_bgcolor="rgba(255,255,255,1)",
            title_font_size=20,
            title_x=0.5,
        )
        self.fig.update_xaxes(
            range=(0, self.max_time + 1),  # TODO: Add X% padding if requested
            showline=True,
            linewidth=1,
            linecolor="black",
            mirror=True,
        )
        self.fig.update_yaxes(
            showline=True,
            linewidth=1,
            linecolor="black",
            mirror=True,
            gridcolor="rgba(38,38,38,0.15)",
        )
        self.fig.update_layout(
            xaxis_type="linear",
            xaxis_title="Cycles",  # TODO: convert to time if requested
            yaxis_title="Channel",
            height=200 + 60 * len(self.channels),
        )
        self.fig.update_layout(
            xaxis={
                "rangeselector": {"buttons": list([])},
                "rangeslider": {"visible": True},
            }
        )

    def finalize_figure(self) -> go.Figure:
        """
        TODO: Add docs
        """
        # Update the xtick values
        self.fig.update_layout(
            yaxis={
                "tickmode": "array",
                "tickvals": list(range(0, len(self.channels))),
                "ticktext": self.channels,
            }
        )

        # update annotation hovering
        self.fig.update_traces(
            hoverinfo="x+text",
            marker={"size": 0.01},
            mode="lines+markers",
        )

        return self.fig

    def create_figure(self, filter_awgr: bool = False, filter_barrier: bool = False) -> go.Figure:
        """
        TODO: Add docs
        Generate a figure representing the circuit schedule
        """

        # Create an empty figure with the x-axis and y-axis populated
        self.fig = go.Figure()
        self.setup_figure()

        # Process instructions
        shift_phase_instructions = []
        for row in self.df.iterrows():
            (_, _, _, _, _, pulse, _) = self.unpack_row(row)
            if "shift_phase" not in pulse:
                # Process instructions of finite duration
                self.trace_finite_duration_instruction(row)
            else:
                # cache for later tracing so it won't be covered
                shift_phase_instructions.append(row)

        # Process instructions of zero duration
        for row in shift_phase_instructions:
            self.trace_zero_duration_instruction(row)

        # Add annotations
        self.fig["layout"]["annotations"] = self.annotations

        # Add a button to control annotations display
        self.fig.update_layout(
            updatemenus=[
                dict(
                    type="dropdown",
                    direction="down",
                    buttons=list(
                        [
                            dict(
                                args=[{"annotations": self.fig.layout.annotations}],
                                label="Show Annotations",
                                method="relayout",
                            ),
                            dict(
                                args=[{"annotations": []}],
                                label="Hide Annotations",
                                method="relayout",
                            ),
                        ]
                    ),
                    pad={"r": 10, "t": 10},
                    showactive=True,
                    x=0,
                    xanchor="left",
                    y=1.1,
                    yanchor="top",
                )
            ]
        )

        return self.finalize_figure()

