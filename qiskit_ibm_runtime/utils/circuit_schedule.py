# This code is part of Qiskit.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Utilities for working with circuit schedule timing information returned from the compiler."""

from itertools import cycle
from typing import Tuple, List
import os.path
import numpy as np
from plotly.graph_objects import Figure as PlotlyFigure  # TODO: replace with TYPE_CHECkING

from ..visualization.utils import plotly_module

go = plotly_module(".graph_objects")
colors = plotly_module(".colors").qualitative.Plotly


READOUT_CHANNEL_PREFIX = "AWGR"
BARRIER = "barrier"


class CircuitSchedule:
    """
    TODO: Add docs.
    The Schedule class encapsulates the data of a Qiskit circuit schedule and contains the functionality
    to visualize it
    """

    def __init__(
        self,
        circuit_schedule: str | List[str],
    ):
        """
        TODO: Add docs.
        Initialize a Schedule object using the schedule file generated by the compiler
        """
        self.channels = None
        self.type_to_idx = None
        self.circuit_scheduling = None

        raw_data = self._load(circuit_schedule)
        self._parse(raw_data)

        self.instruction_set = set()
        self.max_time = None
        self.color_map = {}
        self.annotations = []
        self.legend = set()
        self.traces = []

    @classmethod
    def _load(cls, circuit_schedule: str | List[str]) -> List[str]:
        """
        TODO: Add checks and docs
        """
        if isinstance(circuit_schedule, str):
            if os.path.exists(circuit_schedule) and os.path.isfile(circuit_schedule):
                with open(circuit_schedule, encoding="utf-8") as file:
                    data = file.readlines()
            else:
                raise FileExistsError(f"{circuit_schedule} is missing.")
        elif isinstance(circuit_schedule, list):
            data = circuit_schedule
        else:
            raise TypeError("CircuitSchedule expects a str or a list.")

        return data

    def _parse(self, raw_data: List[str]):
        """
        TODO: Add checks and docs
        """
        circuit_scheduling = []
        for line in raw_data:
            if line == "":
                continue
            words = line.split(",")
            if "shift_phase" in words[0]:
                continue
            if len(words) != 6:
                raise ValueError(
                    "Cannot interpret timeline data that doesn't have the format \\\
                        <Branch, Instruction, Channel, T0, Duration, Pulse>"
                )
            circuit_scheduling.append(
                [
                    words[0],  # Branch
                    words[1],  # Instruction
                    words[2],  # Channel
                    words[3],  # Start
                    str(int(words[3]) + int(words[4])),  # Finish
                    words[5],  # Pulse
                    words[1].split("_")[0],  # GateName
                ]
            )
        data_names = ["Branch", "Instruction", "Channel", "Start", "Finish", "Pulse", "GateName"]
        self.type_to_idx = {data_name: idx for idx, data_name in enumerate(data_names)}
        self.circuit_scheduling = np.array(circuit_scheduling)

    def preprocess(
        self,
        filter_awgr: bool = False,
        filter_barriers: bool = False,
        included_channels: list = None,
    ):
        """
        TODO: Add checks and docs
        """
        # filter channels
        if included_channels is not None and isinstance(included_channels, list):
            mask = np.isin(
                self.circuit_scheduling[:, self.type_to_idx["Channel"]], included_channels
            )
            self.circuit_scheduling = self.circuit_scheduling[mask]

        # filter AWGR channels
        if filter_awgr:
            mask = ~np.char.startswith(
                self.circuit_scheduling[:, self.type_to_idx["Channel"]], READOUT_CHANNEL_PREFIX
            )
            self.circuit_scheduling = self.circuit_scheduling[mask]

        # filter barriers
        if filter_barriers:
            mask = self.circuit_scheduling[:, self.type_to_idx["Instruction"]] != BARRIER
            self.circuit_scheduling = self.circuit_scheduling[mask]

        self.circuit_scheduling = self.circuit_scheduling[
            np.argsort(self.circuit_scheduling[:, self.type_to_idx["Channel"]])
        ]
        self.channels = np.unique(
            self.circuit_scheduling[:, self.type_to_idx["Channel"]]
        )  # TODO: maybe `instruments` is better?
        self.channels.sort()
        self.channels = list(self.channels)
        self.max_time = int(max(self.circuit_scheduling[:, self.type_to_idx["Finish"]]))
        self.instruction_set = np.unique(self.circuit_scheduling[:, self.type_to_idx["GateName"]])
        self.color_map = dict(zip(self.instruction_set, cycle(colors)))

    def get_trace_finite_duration_y_shift(self, branch: str) -> Tuple[float, float, float]:
        """
        TODO: Add docs
        Get offsets for generated rectangles
        """
        if branch == "main":
            return (-0.4, 0.4, 0)
        elif branch == "then":
            return (0, 0.4, 0.25)
        elif branch == "else":
            return (-0.4, 0, -0.25)
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def get_trace_zero_duration_y_shift(self, branch: str) -> float:
        """
        TODO: Add docs
        Get offsets for generated diamonds
        """
        if branch == "main":
            return 0
        elif branch == "then":
            return 0.2
        elif branch == "else":
            return -0.2
        else:
            raise ValueError(f"Unexpected branch provided: {branch}")

    def trace_finite_duration_instruction(self, row):
        """
        TODO: Add docs
        Generate rectangles
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = row
        t_i, t_f = int(t_i), int(t_f)

        # compute trace y-position
        y0, y1, annotation_y = self.get_trace_finite_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_low = channel_y_loc + y0
        y_high = channel_y_loc + y1

        # extend barriers vertically beyond operations
        if gate_name == BARRIER:
            y0 -= 0.05
            y1 += 0.05

        # Get gate trace
        # the gate is drawn as a 6-point closed rectangular to
        # allow convenient annotation display when hover
        trace = go.Scatter(
            x=[
                t_i,
                (t_i + t_f) / 2,
                t_f,
                t_f,
                (t_i + t_f) / 2,
                t_i,
                t_i,
                None,
            ],  # TODO: Figure out the None in the end
            y=[
                y_low,
                y_low,
                y_low,
                y_high,
                y_high,
                y_high,
                y_low,
                None,
            ],  # TODO: Figure out the None in the end
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    "Instruction: " + instruction,
                    "Pulse: " + pulse,
                    "Start: " + str(t_i),
                    "Finish: " + str(t_f),
                    "Duration: " + str(t_f - t_i),
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )
        self.traces.append(trace)

        # Get trace annotation
        # hide text if drawing a barrier
        text = "" if gate_name == BARRIER else f"{gate_name}_{pulse}"
        annotation = {
            "x": (t_i + t_f) / 2,
            "y": channel_y_loc + annotation_y,
            "showarrow": False,
            "font": {"color": "black", "size": 10},
            "text": text,
            "textangle": 0,
        }
        self.annotations.append(annotation)

    def trace_zero_duration_instruction(self, row):
        """
        TODO: Add docs
        Generate diamonds
        """
        (branch, instruction, channel, t_i, t_f, pulse, gate_name) = row
        t_i, t_f = int(t_i), int(t_f)

        y_shift = self.get_trace_zero_duration_y_shift(branch)
        channel_y_loc = self.channels.index(channel)
        y_mid = channel_y_loc + y_shift
        y_low = y_mid - 0.2
        y_high = y_mid + 0.2

        # Get trace
        # drawing zero duration traces as diamonds
        trace = go.Scatter(
            x=[t_i, t_i + 1, t_i, t_i - 1, t_i, None],
            y=[y_low, y_mid, y_high, y_mid, y_low, None],
            mode="markers",
            hoverinfo="x+text",
            name=gate_name,
            text="<br>".join(
                [
                    f"Instruction: {instruction}",
                    f"Pulse: {pulse}",
                    f"Start: {t_i}",
                    f"Finish: {t_f}",
                    f"Duration: {t_f - t_i}",
                ]
            ),
            legendgroup=gate_name,
            line={"color": "black"},
            fill="toself",
            fillcolor=self.color_map[gate_name],
            showlegend=gate_name not in self.legend,
        )
        self.traces.append(trace)

        # Get trace annotation
        annotation = {
            "x": ((t_i + t_f) / 2),
            "y": y_mid,
            "showarrow": True,
            "font": {"color": "black", "size": 10},
            "text": f"{gate_name}_{pulse}",
            "textangle": 0,
        }
        self.annotations.append(annotation)

    def populate_figure(self, fig: PlotlyFigure) -> PlotlyFigure:
        """
        TODO: Add docs
        """
        # Process instructions
        shift_phase_instructions = []
        for row in self.circuit_scheduling:
            (_, _, _, _, _, pulse, gate_name) = row
            if "shift_phase" not in pulse:
                # Trace instructions of finite duration
                self.trace_finite_duration_instruction(row)
                self.legend.add(gate_name)
            else:
                # cache instructions of zero duration
                # for later tracing so it won't be covered
                shift_phase_instructions.append(row)

        # Trace instructions of zero duration
        for row in shift_phase_instructions:
            self.trace_zero_duration_instruction(row)
            self.legend.add(gate_name)

        fig.add_traces(self.traces)
        return fig
