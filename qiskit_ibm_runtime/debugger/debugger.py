# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""A debugger."""

from __future__ import annotations
from typing import Optional, Sequence

from qiskit_aer.noise import NoiseModel
from qiskit_aer.primitives.estimator_v2 import EstimatorV2 as AerEstimator

from qiskit.transpiler.passmanager import PassManager
from qiskit.primitives.containers import EstimatorPubLike
from qiskit.primitives.containers.estimator_pub import EstimatorPub
from qiskit.providers import BackendV2 as Backend

from qiskit_ibm_runtime.debugger.debugger_results import DebuggerResult
from qiskit_ibm_runtime.transpiler.passes.cliffordization import ConvertISAToClifford
from qiskit_ibm_runtime.utils import validate_estimator_pubs, validate_isa_circuits


def _validate_pubs(backend: Backend, pubs: Sequence[EstimatorPub], validate_clifford=True):
    r"""Validates a list PUBs by running the :meth:`.~validate_estimator_pubs` and
    :meth:`.~validate_isa_circuits` methods, and optionally, by checking if the PUBs
    are Clifford.
    """
    validate_estimator_pubs(pubs)
    validate_isa_circuits([pub.circuit for pub in pubs], backend.target)

    if validate_clifford:
        for pub in pubs:
            cliff_circ = PassManager([ConvertISAToClifford()]).run(pub.circuit)
            if pub.circuit != cliff_circ:
                raise ValueError(
                    "Given ``pubs`` contain a non-Clifford circuit. To fix, consider using the "
                    "``ConvertISAToClifford`` pass to map your circuits to the nearest Clifford"
                    " circuits, then try again."
                )


class Debugger:
    r"""A class that users of the Estimator primitive can use to understand the expected
    performance of their queries.

    Args:
        backend: A backend.
        noise_model: A noise model for the operations of the given backend. If ``None``, it
            defaults to the noise model generated by :meth:`NoiseModel.from_backend`.
    """

    def __init__(self, backend: Backend, noise_model: Optional[NoiseModel] = None) -> None:
        self._backend = backend
        self._noise_model = noise_model or NoiseModel.from_backend(
            backend, thermal_relaxation=False
        )

    @property
    def backend(self) -> Backend:
        r"""
        The backend used by this debugger.
        """
        return self._backend

    @property
    def noise_model(self) -> NoiseModel:
        r"""
        The noise model used by this debugger for the noisy simulations.
        """
        return self._noise_model

    def simulate(
        self,
        pubs: Sequence[EstimatorPubLike],
        ideal_sim: bool = False,
    ) -> list[DebuggerResult]:
        r"""
        Calculates the expectation values for the estimator task specified by the given ``pubs``.

        This function uses ``qiskit-aer``'s ``Estimator`` class to simulate the estimation task
        classically. It returns a list of ``DebuggerResult`` objects, each one corresponding to a
        different PUB. Users can subsequently compare debugger results with other debugger results
        or with primitive results to draw figures of merit.

        .. code::python

            # Initialize a debugger
            debugger = Debugger(backend)

            # Calculate the expectation values in the absence of noise
            r_ideal = debugger.simulate(cliff_pubs, ideal_sim=True)

            # Calculate the expectation values in the presence of noise
            r_noisy = debugger.simulate(cliff_pubs, ideal_sim=False)

            # Calculate the ratio between the two
            signal_to_noise_ratio = r_noisy[0]/r_ideal[1]

        .. note::
            To ensure scalability, every circuit in ``pubs`` is required to be a Clifford circuit,
            so that it can be simulated efficiently regardless of its size. For estimation tasks
            that involve non-Clifford circuits, the recommended workflow consists of mapping
            the non-Clifford circuits to the nearest Clifford circuits using the
            :class:`.~ConvertISAToClifford` transpiler pass, or equivalently, to use the debugger's
            :meth:`to_clifford` convenience method.

        Args:
            pubs: The PUBs specifying the estimation task of interest.
            ideal_sim: Whether to perform an ideal, noiseless simulation (``True``) or a noisy
                simulation (``False``).
            seed_simulator: A seed for the simulator.
        """
        _validate_pubs(self.backend, coerced_pubs := [EstimatorPub.coerce(pub) for pub in pubs])

        backend_options = {
            "method": "stabilizer",
            "noise_model": None if ideal_sim else self.noise_model,
        }
        estimator = AerEstimator(options={"backend_options": backend_options})
        return [DebuggerResult(r.data.evs) for r in estimator.run(coerced_pubs).result()]

    def to_clifford(self, pubs: Sequence[EstimatorPubLike]) -> list[EstimatorPub]:
        r"""
        A convenience method that returns the cliffordized version of the given ``pubs``, obtained
        by run the :class:`.~ConvertISAToClifford` transpiler pass on the PUBs' circuits.

        Args:
            pubs: The PUBs to turn into Clifford PUBs.
        Returns:
            The Clifford PUBs.
        """
        coerced_pubs = [EstimatorPub.coerce(pub) for pub in pubs]
        _validate_pubs(self.backend, coerced_pubs, False)

        ret = []
        for pub in coerced_pubs:
            new_pub = EstimatorPub(
                PassManager([ConvertISAToClifford()]).run(pub.circuit),
                pub.observables,
                pub.parameter_values,
                pub.precision,
                False,
            )
            ret.append(new_pub)

        return ret

    def __repr__(self) -> str:
        return f'Debugger(backend="{self.backend.name}")'
