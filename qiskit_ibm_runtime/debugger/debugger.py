# This code is part of Qiskit.
#
# (C) Copyright IBM 2024.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""A debugger."""

from __future__ import annotations
from typing import Iterable, Optional, Union

from qiskit_aer.noise import NoiseModel
from qiskit_aer.primitives import EstimatorV2 as AerEstimator

from qiskit.transpiler.passmanager import PassManager
from qiskit.primitives.containers import EstimatorPubLike, PrimitiveResult
from qiskit.primitives.containers.estimator_pub import EstimatorPub
from qiskit.providers import BackendV1, BackendV2

from qiskit_ibm_runtime.debugger.plugins import Plugin, Ratio
from qiskit_ibm_runtime.transpiler.passes.basis.to_nearest_clifford import ToNearestClifford
from qiskit_ibm_runtime.utils import validate_estimator_pubs, validate_isa_circuits


class Debugger:
    r"""A class that users of the Estimator primitive can use to understand the expected
    performance of their query.

    Args:
        backend: A backend.
        noise_model: A noise model for the operations of the given backend. If ``None``, it
            defaults to the noise model generated by the :meth:`NoiseModel.from_backend`
            method.
    """

    def __init__(
        self, backend: Union[BackendV1, BackendV2], noise_model: Optional[NoiseModel] = None
    ) -> None:
        self._backend = backend
        self._noise_model = noise_model or NoiseModel.from_backend(
            backend, thermal_relaxation=False
        )

    @property
    def backend(self) -> Union[BackendV1, BackendV2]:
        r"""
        The backend.
        """
        return self._backend

    @property
    def noise_model(self) -> NoiseModel:
        r"""
        The noise model.
        """
        return self._noise_model

    def compare(
        self,
        pubs: Iterable[EstimatorPubLike],
        mode1: str = "noisy_sim",
        mode2: str = "ideal_sim",
        results: Optional[PrimitiveResult] = None,
        fom: Optional[Plugin] = Ratio(),
    ):
        r"""
        Given a target estimation task, compare different results obtained by performing an
        ideal simulation of the target task, implementing a noisy simulation of it, or running
        it on an actual backend.

        In more detail, this function allows computing figures of merit that can help understand
        the expected performance of the task.

        Here are a few notable examples that illustrate how this function can be useful:

            * With default values of ``mode1`` (``"noisy_sim"``), ``mode2`` (``"ideal_sim"``), and
            ``fom`` (:class:`.Ratio()`), it classically simulates the estimation task both in the
              presence and in the absence of noise, and it returns the signal-to-noise ratio
              between noisy and ideal results, a quantity that can help predicting the performance
              of error mitigation.

            * Setting ``mode1`` to ``"noisy_sim"`` and ``mode2`` to ``exp``, it compares the
              experimental results with the results of a noisy simulation. This can help understand
              if a given noise model is a good approximation of the noise processes that affect the
              backend in use.

            * Setting ``result1`` to ``"ideal_sim"`` and ``result2`` to ``exp``, it compares the
              experimental results with the results of an ideal simulation. This can help understand
              how well a backend can perform a certain computational task, or (if error mitigation
              was used to obtain the experimental results) the performance of different mitigation
              strategies.

        .. note::
            To ensure scalability, every circuit in ``pubs`` is required to be a Clifford circuit,
            so that it can be simulated efficiently regardless of its size. For estimation tasks
            that involve non-Clifford circuits, the recommended workflow consists of mapping
            the non-Clifford circuits to the nearest Clifford circuits using the
            :class:`.ToNearestClifford`.

        .. note::
            This function assumes, but does not check, that any experimental result provided as an
            input was previously obtained by running the given ``pubs`` on a backend.

        Args:
            pubs: The PUBs specifying the target estimation task.
            mode1: The debugging mode of the first set of results to use in the comparison. Allowed
                values are ``ideal_sim`` for the results of an ideal simulation, ``noisy_sim`` for
                those of a noisy simulation, or ``exp`` to use the give ``results``.
            mode2: The debugging mode of the second set of results to use in the comparison.
                Allowed values are ``ideal_sim``, ``noisy_sim``, or ``exp``.
            results: The experimental results obtained by running the given ``pubs`` on an actual
                experiment. Required if ``mode1`` or ``mode2`` is ``"experiment"``, ignored
                otherwise.
            fom: The figure of merit to compare ``mode1`` and ``mode2`` by. Defaults to computing
                the ratio.
        """
        available_modes = {"ideal_sim", "noisy_sim", "exp"}
        if not set([mode1, mode2]).issubset(available_modes):
            invalid_mode = mode1 if mode1 not in available_modes else mode2
            raise ValueError(
                f"Invalid debugging mode `{invalid_mode}`, must be one of {available_modes}."
            )

        if "exp" in [mode1, mode2] and not results:
            raise ValueError(f"`results` are required when comparing `{mode1}` with `{mode2}`.")

        coerced_pubs = [EstimatorPub.coerce(pub) for pub in pubs]

        # validation
        validate_estimator_pubs(coerced_pubs)
        for pub in coerced_pubs:
            validate_isa_circuits([pub.circuit], self.backend.target)

            # Check that `pub.circuit` is a Clifford circuit
            cliff_circuit = PassManager([ToNearestClifford()]).run(pub.circuit)
            if cliff_circuit != pub.circuit:
                raise ValueError(
                    "Given ``pubs`` contain a non-Clifford circuit. To fix, consider using the "
                    "``ToNearestClifford`` pass to map your circuits to the nearest Clifford "
                    "circuits, then try again."
                )

        def _get_results(mode: str):
            if mode == "ideal_sim":
                options = {"method": "stabilizer"}
                ideal_estimator = AerEstimator(options={"backend_options": options})
                return ideal_estimator.run(coerced_pubs).result()
            elif mode == "noisy_sim":
                options = {"method": "stabilizer", "noise_model": self.noise_model}
                noisy_estimator = AerEstimator(options={"backend_options": options})
                return noisy_estimator.run(coerced_pubs).result()
            else:
                return results

        return _get_results(mode1), _get_results(mode2), fom(_get_results(mode1), _get_results(mode2))

    def __repr__(self) -> str:
        return f'Debugger(backend="{self.backend.name}")'
